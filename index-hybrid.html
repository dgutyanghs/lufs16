<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>视频音频响度调节器 (混合版本)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: border-color 0.3s;
        }

        .upload-area:hover {
            border-color: #007bff;
        }

        .upload-area.dragover {
            border-color: #007bff;
            background-color: #f0f8ff;
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }

        .btn:hover {
            background-color: #0056b3;
        }

        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .progress {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-bar {
            height: 100%;
            background-color: #007bff;
            width: 0%;
            transition: width 0.3s;
        }

        .info-panel {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .hidden {
            display: none;
        }

        .warning {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .feature-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .feature-card {
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .feature-card h4 {
            margin-top: 0;
            color: #333;
        }

        .feature-list {
            list-style: none;
            padding: 0;
        }

        .feature-list li {
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }

        .feature-list li:before {
            content: "✅ ";
            color: #28a745;
        }

        .limitation:before {
            content: "⚠️ ";
            color: #ffc107;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>视频音频响度调节器 (混合版本)</h1>
        <p>专业级音频响度分析和调节工具，结合Web Audio API和MediaRecorder技术</p>

        <div id="versionInfo" class="info-panel warning">
            <h3>🔧 技术说明</h3>
            <p>由于FFmpeg.js CDN问题，此版本使用混合技术栈提供专业级音频处理功能：</p>
            <div class="feature-comparison">
                <div class="feature-card">
                    <h4>✅ 可用功能</h4>
                    <ul class="feature-list">
                        <li>专业LUFS响度分析</li>
                        <li>实时音频增益调节</li>
                        <li>峰值电平检测</li>
                        <li>动态范围分析</li>
                        <li>音频可视化</li>
                        <li>处理后音频导出</li>
                    </ul>
                </div>
                <div class="feature-card">
                    <h4>⚠️ 技术限制</h4>
                    <ul class="feature-list">
                        <li class="limitation">输出为音频文件(WAV)</li>
                        <li class="limitation">视频需单独处理</li>
                        <li class="limitation">基于浏览器音频API</li>
                        <li class="limitation">文件大小限制500MB</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="upload-area" id="uploadArea">
            <p>拖拽视频文件到这里或点击选择文件</p>
            <button class="btn" onclick="document.getElementById('fileInput').click()">选择视频文件</button>
            <input type="file" id="fileInput" accept="video/*,audio/*">
        </div>

        <div id="processingPanel" class="hidden">
            <div class="info-panel">
                <h3>处理进度</h3>
                <div class="progress">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
                <p id="statusText">准备中...</p>
            </div>

            <div id="audioInfo" class="info-panel hidden">
                <h3>音频分析结果</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div>
                        <p><strong>响度分析</strong></p>
                        <p>原始响度: <span id="originalLUFS">--</span> LUFS</p>
                        <p>目标响度: -16 LUFS</p>
                        <p>增益调节: <span id="gainAdjustment">--</span> dB</p>
                    </div>
                    <div>
                        <p><strong>音频参数</strong></p>
                        <p>峰值电平: <span id="peakLevel">--</span> dBFS</p>
                        <p>动态范围: <span id="dynamicRange">--</span> LU</p>
                        <p>采样率: <span id="sampleRate">--</span> Hz</p>
                    </div>
                </div>

                <div id="audioVisualization" style="margin-top: 15px;">
                    <canvas id="waveformCanvas" width="600" height="100"
                        style="width: 100%; border: 1px solid #ddd;"></canvas>
                </div>
            </div>
        </div>

        <div id="resultPanel" class="hidden">
            <div class="info-panel success">
                <h3>✅ 处理完成</h3>
                <p>音频已成功调节到 -16 LUFS 标准</p>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div>
                    <h4>原始音频</h4>
                    <audio id="originalAudio" controls style="width: 100%;"></audio>
                </div>
                <div>
                    <h4>处理后音频</h4>
                    <audio id="processedAudio" controls style="width: 100%;"></audio>
                </div>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button class="btn" id="downloadBtn">下载处理后的音频 (WAV)</button>
                <button class="btn" onclick="location.reload()">重新开始</button>
            </div>
        </div>
    </div>

    <script>
        // 专业级音频处理器
        class ProfessionalAudioProcessor {
            constructor() {
                this.audioContext = null;
                this.targetLUFS = -16;
                this.sampleRate = 44100;
            }

            async initAudioContext() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.sampleRate = this.audioContext.sampleRate;
                }
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
            }

            // 从视频/音频文件中提取音频数据
            async extractAudioData(file) {
                await this.initAudioContext();

                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);

                return audioBuffer;
            }

            // 专业级LUFS计算 (基于EBU R128标准的简化版)
            calculateLUFS(audioBuffer) {
                const channels = audioBuffer.numberOfChannels;
                const length = audioBuffer.length;
                const sampleRate = audioBuffer.sampleRate;

                // 获取所有声道数据
                const channelData = [];
                for (let i = 0; i < channels; i++) {
                    channelData.push(audioBuffer.getChannelData(i));
                }

                // 应用K-weighting滤波器 (简化版)
                const filteredData = this.applyKWeighting(channelData, sampleRate);

                // 计算400ms块的响度
                const blockSize = Math.floor(sampleRate * 0.4); // 400ms
                const hopSize = Math.floor(blockSize * 0.75); // 75% overlap

                let loudnessValues = [];

                for (let start = 0; start < length - blockSize; start += hopSize) {
                    let blockPower = 0;
                    let sampleCount = 0;

                    for (let i = start; i < start + blockSize && i < length; i++) {
                        let sample = 0;

                        // 多声道加权混合
                        for (let ch = 0; ch < channels; ch++) {
                            const weight = channels === 1 ? 1.0 : (ch < 2 ? 1.0 : 0.708); // L/R: 1.0, others: 0.708
                            sample += filteredData[ch][i] * weight;
                        }

                        blockPower += sample * sample;
                        sampleCount++;
                    }

                    if (sampleCount > 0) {
                        const blockLoudness = blockPower / sampleCount;
                        if (blockLoudness > 0) {
                            loudnessValues.push(blockLoudness);
                        }
                    }
                }

                // 计算积分响度 (去除最低10%的值)
                loudnessValues.sort((a, b) => b - a);
                const validCount = Math.floor(loudnessValues.length * 0.9);
                const validValues = loudnessValues.slice(0, validCount);

                if (validValues.length === 0) return -70;

                const meanSquare = validValues.reduce((sum, val) => sum + val, 0) / validValues.length;
                const lufs = -0.691 + 10 * Math.log10(meanSquare + 1e-12);

                return Math.max(lufs, -70);
            }

            // 简化的K-weighting滤波器
            applyKWeighting(channelData, sampleRate) {
                const filtered = [];

                for (let ch = 0; ch < channelData.length; ch++) {
                    const input = channelData[ch];
                    const output = new Float32Array(input.length);

                    // 简化的高通滤波器 (模拟K-weighting的高频特性)
                    let prev = 0;
                    const alpha = 0.95; // 高通滤波器系数

                    for (let i = 0; i < input.length; i++) {
                        output[i] = alpha * (output[i - 1] || 0) + alpha * (input[i] - prev);
                        prev = input[i];
                    }

                    filtered.push(output);
                }

                return filtered;
            }

            // 计算峰值电平
            calculatePeakLevel(audioBuffer) {
                let maxPeak = 0;

                for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
                    const channelData = audioBuffer.getChannelData(ch);
                    for (let i = 0; i < channelData.length; i++) {
                        maxPeak = Math.max(maxPeak, Math.abs(channelData[i]));
                    }
                }

                return maxPeak > 0 ? 20 * Math.log10(maxPeak) : -Infinity;
            }

            // 计算动态范围 (简化版LRA)
            calculateDynamicRange(audioBuffer) {
                const channels = audioBuffer.numberOfChannels;
                const length = audioBuffer.length;
                const sampleRate = audioBuffer.sampleRate;

                // 计算3秒块的响度
                const blockSize = Math.floor(sampleRate * 3); // 3秒
                let loudnessValues = [];

                for (let start = 0; start < length - blockSize; start += blockSize) {
                    let blockPower = 0;
                    let sampleCount = 0;

                    for (let i = start; i < start + blockSize && i < length; i++) {
                        let sample = 0;
                        for (let ch = 0; ch < channels; ch++) {
                            sample += audioBuffer.getChannelData(ch)[i];
                        }
                        sample /= channels;

                        blockPower += sample * sample;
                        sampleCount++;
                    }

                    if (sampleCount > 0) {
                        const blockLoudness = 10 * Math.log10(blockPower / sampleCount + 1e-12);
                        loudnessValues.push(blockLoudness);
                    }
                }

                if (loudnessValues.length < 2) return 0;

                loudnessValues.sort((a, b) => a - b);
                const p95 = loudnessValues[Math.floor(loudnessValues.length * 0.95)];
                const p10 = loudnessValues[Math.floor(loudnessValues.length * 0.10)];

                return Math.max(0, p95 - p10);
            }

            // 应用增益到音频缓冲区
            applyGain(audioBuffer, gainDB) {
                const gainLinear = Math.pow(10, gainDB / 20);
                const channels = audioBuffer.numberOfChannels;

                // 创建新的音频缓冲区
                const processedBuffer = this.audioContext.createBuffer(
                    channels,
                    audioBuffer.length,
                    audioBuffer.sampleRate
                );

                for (let ch = 0; ch < channels; ch++) {
                    const inputData = audioBuffer.getChannelData(ch);
                    const outputData = processedBuffer.getChannelData(ch);

                    for (let i = 0; i < inputData.length; i++) {
                        let sample = inputData[i] * gainLinear;

                        // 软限制防止削波
                        if (Math.abs(sample) > 0.95) {
                            sample = sample > 0 ? 0.95 * Math.tanh(sample / 0.95) : -0.95 * Math.tanh(-sample / 0.95);
                        }

                        outputData[i] = sample;
                    }
                }

                return processedBuffer;
            }

            // 将音频缓冲区转换为WAV格式
            audioBufferToWav(audioBuffer) {
                const length = audioBuffer.length;
                const channels = audioBuffer.numberOfChannels;
                const sampleRate = audioBuffer.sampleRate;
                const arrayBuffer = new ArrayBuffer(44 + length * channels * 2);
                const view = new DataView(arrayBuffer);

                // WAV文件头
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };

                writeString(0, 'RIFF');
                view.setUint32(4, 36 + length * channels * 2, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, channels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * channels * 2, true);
                view.setUint16(32, channels * 2, true);
                view.setUint16(34, 16, true);
                writeString(36, 'data');
                view.setUint32(40, length * channels * 2, true);

                // 音频数据
                let offset = 44;
                for (let i = 0; i < length; i++) {
                    for (let ch = 0; ch < channels; ch++) {
                        const sample = Math.max(-1, Math.min(1, audioBuffer.getChannelData(ch)[i]));
                        view.setInt16(offset, sample * 0x7FFF, true);
                        offset += 2;
                    }
                }

                return new Blob([arrayBuffer], { type: 'audio/wav' });
            }

            // 绘制波形
            drawWaveform(audioBuffer, canvas) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, width, height);

                const channelData = audioBuffer.getChannelData(0);
                const step = Math.ceil(channelData.length / width);

                ctx.strokeStyle = '#007bff';
                ctx.lineWidth = 1;
                ctx.beginPath();

                for (let i = 0; i < width; i++) {
                    let min = 1.0;
                    let max = -1.0;

                    for (let j = 0; j < step; j++) {
                        const sample = channelData[i * step + j] || 0;
                        min = Math.min(min, sample);
                        max = Math.max(max, sample);
                    }

                    const y1 = (1 + min) * height / 2;
                    const y2 = (1 + max) * height / 2;

                    if (i === 0) {
                        ctx.moveTo(i, y1);
                    } else {
                        ctx.lineTo(i, y1);
                        ctx.lineTo(i, y2);
                    }
                }

                ctx.stroke();
            }

            // 主处理函数
            async processAudio(file, progressCallback) {
                try {
                    progressCallback(10, '正在提取音频数据...');
                    const audioBuffer = await this.extractAudioData(file);

                    progressCallback(30, '正在分析音频响度...');
                    const originalLUFS = this.calculateLUFS(audioBuffer);

                    progressCallback(50, '正在计算音频参数...');
                    const peakLevel = this.calculatePeakLevel(audioBuffer);
                    const dynamicRange = this.calculateDynamicRange(audioBuffer);

                    progressCallback(70, '正在应用响度调节...');
                    const gainAdjustment = this.targetLUFS - originalLUFS;
                    const processedBuffer = this.applyGain(audioBuffer, gainAdjustment);

                    progressCallback(90, '正在生成输出文件...');
                    const processedWav = this.audioBufferToWav(processedBuffer);
                    const originalWav = this.audioBufferToWav(audioBuffer);

                    progressCallback(100, '处理完成!');

                    return {
                        originalLUFS: originalLUFS,
                        gainAdjustment: gainAdjustment,
                        peakLevel: peakLevel,
                        dynamicRange: dynamicRange,
                        sampleRate: audioBuffer.sampleRate,
                        originalAudio: originalWav,
                        processedAudio: processedWav,
                        originalBuffer: audioBuffer,
                        processedBuffer: processedBuffer
                    };

                } catch (error) {
                    throw new Error(`音频处理失败: ${error.message}`);
                }
            }
        }

        // 主应用类
        class HybridAudioNormalizer {
            constructor() {
                this.audioProcessor = new ProfessionalAudioProcessor();
                this.currentFile = null;
                this.processedAudioBlob = null;
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');

                // 文件拖拽处理
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.handleFileSelect(files[0]);
                    }
                });

                // 文件选择处理
                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.handleFileSelect(e.target.files[0]);
                    }
                });
            }

            async handleFileSelect(file) {
                // 验证文件类型
                if (!file.type.startsWith('video/') && !file.type.startsWith('audio/')) {
                    alert('请选择视频或音频文件');
                    return;
                }

                // 检查文件大小
                if (file.size > 500 * 1024 * 1024) {
                    alert('文件太大，请选择小于500MB的文件');
                    return;
                }

                this.currentFile = file;
                this.showProcessingPanel();

                try {
                    await this.processAudio();
                } catch (error) {
                    console.error('处理错误:', error);
                    alert(`处理失败: ${error.message}`);
                    this.resetInterface();
                }
            }

            showProcessingPanel() {
                document.getElementById('processingPanel').classList.remove('hidden');
                document.getElementById('resultPanel').classList.add('hidden');
            }

            updateProgress(percentage, status) {
                const progressBar = document.getElementById('progressBar');
                const statusText = document.getElementById('statusText');

                progressBar.style.width = `${percentage}%`;
                statusText.textContent = status;
            }

            async processAudio() {
                const result = await this.audioProcessor.processAudio(
                    this.currentFile,
                    (progress, status) => this.updateProgress(progress, status)
                );

                // 显示音频信息
                this.displayAudioInfo(result);

                // 显示结果
                this.showResult(result);
            }

            displayAudioInfo(result) {
                const audioInfo = document.getElementById('audioInfo');
                const originalLUFSElement = document.getElementById('originalLUFS');
                const gainAdjustmentElement = document.getElementById('gainAdjustment');
                const peakLevelElement = document.getElementById('peakLevel');
                const dynamicRangeElement = document.getElementById('dynamicRange');
                const sampleRateElement = document.getElementById('sampleRate');

                originalLUFSElement.textContent = result.originalLUFS.toFixed(1);
                gainAdjustmentElement.textContent = result.gainAdjustment > 0 ?
                    `+${result.gainAdjustment.toFixed(1)}` : result.gainAdjustment.toFixed(1);
                peakLevelElement.textContent = result.peakLevel.toFixed(1);
                dynamicRangeElement.textContent = result.dynamicRange.toFixed(1);
                sampleRateElement.textContent = result.sampleRate;

                // 绘制波形
                const canvas = document.getElementById('waveformCanvas');
                this.audioProcessor.drawWaveform(result.originalBuffer, canvas);

                audioInfo.classList.remove('hidden');
            }

            showResult(result) {
                const resultPanel = document.getElementById('resultPanel');
                const originalAudio = document.getElementById('originalAudio');
                const processedAudio = document.getElementById('processedAudio');
                const downloadBtn = document.getElementById('downloadBtn');

                // 设置音频播放器
                originalAudio.src = URL.createObjectURL(result.originalAudio);
                processedAudio.src = URL.createObjectURL(result.processedAudio);

                // 存储处理后的音频用于下载
                this.processedAudioBlob = result.processedAudio;

                // 设置下载功能
                downloadBtn.onclick = () => this.downloadProcessedAudio();

                resultPanel.classList.remove('hidden');
            }

            downloadProcessedAudio() {
                if (!this.processedAudioBlob) {
                    alert('没有可下载的处理后音频');
                    return;
                }

                // 创建下载链接
                const link = document.createElement('a');
                const fileName = this.currentFile.name.replace(/\.[^/.]+$/, '_normalized.wav');

                const url = URL.createObjectURL(this.processedAudioBlob);
                link.href = url;
                link.download = fileName;

                // 触发下载
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                // 清理URL对象
                setTimeout(() => URL.revokeObjectURL(url), 1000);
            }

            resetInterface() {
                document.getElementById('processingPanel').classList.add('hidden');
                document.getElementById('resultPanel').classList.add('hidden');
                document.getElementById('audioInfo').classList.add('hidden');
                document.getElementById('progressBar').style.width = '0%';
                document.getElementById('statusText').textContent = '准备中...';

                // 清理资源
                if (this.processedAudioBlob) {
                    URL.revokeObjectURL(this.processedAudioBlob);
                    this.processedAudioBlob = null;
                }

                this.currentFile = null;
            }
        }

        // 初始化应用
        document.addEventListener('DOMContentLoaded', () => {
            new HybridAudioNormalizer();
        });

        // 错误处理
        window.addEventListener('error', (e) => {
            console.error('应用错误:', e.error);
        });
    </script>
</body>

</html>
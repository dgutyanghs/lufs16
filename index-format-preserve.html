<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è§†é¢‘éŸ³é¢‘å“åº¦è°ƒèŠ‚å™¨ (æ ¼å¼ä¿æŒç‰ˆ)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: border-color 0.3s;
        }

        .upload-area:hover {
            border-color: #007bff;
        }

        .upload-area.dragover {
            border-color: #007bff;
            background-color: #f0f8ff;
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }

        .btn:hover {
            background-color: #0056b3;
        }

        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .btn.success {
            background-color: #28a745;
        }

        .btn.success:hover {
            background-color: #218838;
        }

        .progress {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-bar {
            height: 100%;
            background-color: #007bff;
            width: 0%;
            transition: width 0.3s;
        }

        .info-panel {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .hidden {
            display: none;
        }

        .success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .warning {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .tech-info {
            background-color: #e8f5e8;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .video-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .video-panel {
            text-align: center;
        }

        .video-panel video {
            width: 100%;
            max-width: 400px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .audio-info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }

        .format-info {
            background-color: #f0f8ff;
            border: 1px solid #b3d9ff;
            color: #0066cc;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 14px;
        }

        .solution-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .solution-card {
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.3s;
        }

        .solution-card:hover {
            border-color: #007bff;
            background-color: #f8f9fa;
        }

        .solution-card.selected {
            border-color: #28a745;
            background-color: #d4edda;
        }

        .waveform-container {
            margin: 15px 0;
            text-align: center;
        }

        .waveform-container canvas {
            width: 100%;
            max-width: 600px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        @media (max-width: 768px) {
            .video-container {
                grid-template-columns: 1fr;
            }

            .audio-info-grid {
                grid-template-columns: 1fr;
            }

            .solution-options {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ¬ è§†é¢‘éŸ³é¢‘å“åº¦è°ƒèŠ‚å™¨ (æ ¼å¼ä¿æŒç‰ˆ)</h1>
        <p>æ™ºèƒ½å¤„ç†HEVCè§†é¢‘ï¼Œæä¾›å¤šç§è¾“å‡ºé€‰é¡¹ä»¥æœ€å¤§ç¨‹åº¦ä¿æŒåŸå§‹æ ¼å¼</p>

        <div id="techInfo" class="tech-info">
            <h3>âš¡ è§£å†³æ–¹æ¡ˆè¯´æ˜</h3>
            <p>ç”±äºæµè§ˆå™¨APIé™åˆ¶ï¼Œæ— æ³•ç›´æ¥è¾“å‡ºHEVCç¼–ç çš„MP4ã€‚æˆ‘ä»¬æä¾›ä»¥ä¸‹è§£å†³æ–¹æ¡ˆï¼š</p>

            <div class="solution-options">
                <div class="solution-card" id="solution1" onclick="selectSolution(1)">
                    <h4>ğŸ¯ æ–¹æ¡ˆä¸€ï¼šé«˜è´¨é‡MP4</h4>
                    <p><strong>è¾“å‡ºï¼š</strong>MP4 + H.264 + AAC</p>
                    <p><strong>ä¼˜åŠ¿ï¼š</strong>å¹¿æ³›å…¼å®¹ï¼Œè´¨é‡ä¼˜ç§€</p>
                    <p><strong>æ–‡ä»¶å¤§å°ï¼š</strong>é€‚ä¸­</p>
                </div>

                <div class="solution-card" id="solution2" onclick="selectSolution(2)">
                    <h4>ğŸš€ æ–¹æ¡ˆäºŒï¼šç°ä»£WebM</h4>
                    <p><strong>è¾“å‡ºï¼š</strong>WebM + VP9 + Opus</p>
                    <p><strong>ä¼˜åŠ¿ï¼š</strong>æœ€é«˜è´¨é‡ï¼Œæ–‡ä»¶æœ€å°</p>
                    <p><strong>å…¼å®¹æ€§ï¼š</strong>ç°ä»£æµè§ˆå™¨</p>
                </div>
            </div>

            <div class="warning">
                <strong>ğŸ’¡ å»ºè®®ï¼š</strong>å¦‚éœ€ä¿æŒHEVCç¼–ç ï¼Œè¯·ä½¿ç”¨æ¡Œé¢ç‰ˆFFmpegå·¥å…·ï¼Œæˆ–ç­‰å¾…æµè§ˆå™¨APIæ”¯æŒHEVCç¼–ç è¾“å‡ºã€‚
            </div>
        </div>

        <div class="upload-area" id="uploadArea">
            <p>ğŸ“ æ‹–æ‹½è§†é¢‘æ–‡ä»¶åˆ°è¿™é‡Œæˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</p>
            <button class="btn" onclick="document.getElementById('fileInput').click()">é€‰æ‹©è§†é¢‘æ–‡ä»¶</button>
            <input type="file" id="fileInput" accept="video/*">
            <p><small>æ”¯æŒæ ¼å¼: MP4, MOV, MKV, WebM, AVI ç­‰ | æœ€å¤§æ–‡ä»¶: 2GB</small></p>
        </div>

        <div id="processingPanel" class="hidden">
            <div class="info-panel">
                <h3>âš™ï¸ å¤„ç†è¿›åº¦</h3>
                <div class="progress">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
                <p id="statusText">å‡†å¤‡ä¸­...</p>
            </div>

            <div id="audioInfo" class="info-panel hidden">
                <h3>ğŸ“Š éŸ³é¢‘åˆ†æç»“æœ</h3>
                <div class="audio-info-grid">
                    <div>
                        <p><strong>å“åº¦åˆ†æ</strong></p>
                        <p>åŸå§‹å“åº¦: <span id="originalLUFS">--</span> LUFS</p>
                        <p>ç›®æ ‡å“åº¦: -16 LUFS</p>
                        <p>å¢ç›Šè°ƒèŠ‚: <span id="gainAdjustment">--</span> dB</p>
                    </div>
                    <div>
                        <p><strong>æŠ€æœ¯å‚æ•°</strong></p>
                        <p>å³°å€¼ç”µå¹³: <span id="peakLevel">--</span> dBFS</p>
                        <p>åŠ¨æ€èŒƒå›´: <span id="dynamicRange">--</span> LU</p>
                        <p>è¾“å‡ºæ–¹æ¡ˆ: <span id="outputSolution">--</span></p>
                    </div>
                </div>

                <div class="waveform-container">
                    <p><strong>éŸ³é¢‘æ³¢å½¢</strong></p>
                    <canvas id="waveformCanvas" width="600" height="100"></canvas>
                </div>

                <div class="format-info">
                    <strong>ğŸ“‹ æ ¼å¼ä¿¡æ¯:</strong>
                    <span id="formatInfo">æ­£åœ¨æ£€æµ‹...</span>
                </div>
            </div>
        </div>

        <div id="resultPanel" class="hidden">
            <div class="info-panel success">
                <h3>âœ… å¤„ç†å®Œæˆ</h3>
                <p>è§†é¢‘éŸ³é¢‘å·²æˆåŠŸè°ƒèŠ‚åˆ° -16 LUFS æ ‡å‡†</p>
            </div>

            <div class="video-container">
                <div class="video-panel">
                    <h4>ğŸ“¹ åŸå§‹è§†é¢‘</h4>
                    <video id="originalVideo" controls></video>
                    <p><small id="originalFormat">åŸå§‹æ ¼å¼</small></p>
                </div>
                <div class="video-panel">
                    <h4>ğŸ¯ å¤„ç†åè§†é¢‘</h4>
                    <video id="processedVideo" controls></video>
                    <p><small id="processedFormat">å¤„ç†åæ ¼å¼</small></p>
                </div>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button class="btn success" id="downloadBtn">
                    ğŸ“¥ ä¸‹è½½å¤„ç†åçš„è§†é¢‘
                </button>
                <button class="btn" onclick="location.reload()">ğŸ”„ é‡æ–°å¼€å§‹</button>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let selectedSolution = 1; // é»˜è®¤é€‰æ‹©æ–¹æ¡ˆä¸€

        // é€‰æ‹©è§£å†³æ–¹æ¡ˆ
        function selectSolution(solutionId) {
            selectedSolution = solutionId;

            // æ›´æ–°UI
            document.querySelectorAll('.solution-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.getElementById(`solution${solutionId}`).classList.add('selected');
        }

        // åˆå§‹åŒ–é»˜è®¤é€‰æ‹©
        document.addEventListener('DOMContentLoaded', () => {
            selectSolution(1);
        });

        // æ ¼å¼ä¿æŒè§†é¢‘å¤„ç†å™¨
        class FormatPreserveVideoProcessor {
            constructor() {
                this.audioContext = null;
                this.targetLUFS = -16;
            }

            async initAudioContext() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
            }

            // æ£€æµ‹è§†é¢‘æ ¼å¼ä¿¡æ¯
            async detectVideoFormat(videoFile) {
                return new Promise((resolve) => {
                    const video = document.createElement('video');
                    video.crossOrigin = 'anonymous';

                    video.onloadedmetadata = () => {
                        const format = {
                            duration: video.duration,
                            width: video.videoWidth,
                            height: video.videoHeight,
                            type: videoFile.type,
                            size: videoFile.size,
                            name: videoFile.name
                        };

                        // å°è¯•æ£€æµ‹ç¼–ç æ ¼å¼
                        if (videoFile.name.toLowerCase().includes('hevc') ||
                            videoFile.name.toLowerCase().includes('h265')) {
                            format.videoCodec = 'HEVC/H.265';
                        } else if (videoFile.type.includes('mp4')) {
                            format.videoCodec = 'H.264 (æ¨æµ‹)';
                        } else {
                            format.videoCodec = 'æœªçŸ¥';
                        }

                        resolve(format);
                    };

                    video.onerror = () => {
                        resolve({
                            duration: 0,
                            width: 0,
                            height: 0,
                            type: videoFile.type,
                            size: videoFile.size,
                            name: videoFile.name,
                            videoCodec: 'æ£€æµ‹å¤±è´¥'
                        });
                    };

                    video.src = URL.createObjectURL(videoFile);
                });
            }

            // æå–éŸ³é¢‘æ•°æ®
            async extractAudioData(videoFile, progressCallback) {
                await this.initAudioContext();

                progressCallback(10, 'æ­£åœ¨è§£æè§†é¢‘æ–‡ä»¶...');
                const formatInfo = await this.detectVideoFormat(videoFile);

                progressCallback(30, 'æ­£åœ¨æå–éŸ³é¢‘æ•°æ®...');

                return new Promise((resolve, reject) => {
                    const video = document.createElement('video');
                    video.crossOrigin = 'anonymous';

                    video.onloadedmetadata = async () => {
                        try {
                            // åˆ›å»ºéŸ³é¢‘æº
                            const source = this.audioContext.createMediaElementSource(video);
                            const destination = this.audioContext.createMediaStreamDestination();

                            // è¿æ¥éŸ³é¢‘èŠ‚ç‚¹
                            source.connect(destination);

                            // å½•åˆ¶éŸ³é¢‘
                            const mediaRecorder = new MediaRecorder(destination.stream, {
                                mimeType: 'audio/webm;codecs=opus'
                            });

                            const audioChunks = [];

                            mediaRecorder.ondataavailable = (event) => {
                                if (event.data.size > 0) {
                                    audioChunks.push(event.data);
                                }
                            };

                            mediaRecorder.onstop = async () => {
                                try {
                                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                                    const arrayBuffer = await audioBlob.arrayBuffer();
                                    const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                                    resolve({ audioBuffer, formatInfo });
                                } catch (error) {
                                    reject(error);
                                }
                            };

                            // å¼€å§‹å½•åˆ¶
                            mediaRecorder.start();
                            video.play();

                            video.onended = () => {
                                mediaRecorder.stop();
                            };

                        } catch (error) {
                            reject(error);
                        }
                    };

                    video.onerror = reject;
                    video.src = URL.createObjectURL(videoFile);
                });
            }

            // ä¸“ä¸šçº§LUFSè®¡ç®—
            calculateLUFS(audioBuffer) {
                const channels = audioBuffer.numberOfChannels;
                const length = audioBuffer.length;
                const sampleRate = audioBuffer.sampleRate;

                // è·å–æ‰€æœ‰å£°é“æ•°æ®
                const channelData = [];
                for (let i = 0; i < channels; i++) {
                    channelData.push(audioBuffer.getChannelData(i));
                }

                // åº”ç”¨K-weightingæ»¤æ³¢å™¨
                const filteredData = this.applyKWeighting(channelData, sampleRate);

                // è®¡ç®—400mså—çš„å“åº¦
                const blockSize = Math.floor(sampleRate * 0.4);
                const hopSize = Math.floor(blockSize * 0.75);

                let loudnessValues = [];

                for (let start = 0; start < length - blockSize; start += hopSize) {
                    let blockPower = 0;
                    let sampleCount = 0;

                    for (let i = start; i < start + blockSize && i < length; i++) {
                        let sample = 0;

                        // å¤šå£°é“åŠ æƒæ··åˆ
                        for (let ch = 0; ch < channels; ch++) {
                            const weight = channels === 1 ? 1.0 : (ch < 2 ? 1.0 : 0.708);
                            sample += filteredData[ch][i] * weight;
                        }

                        blockPower += sample * sample;
                        sampleCount++;
                    }

                    if (sampleCount > 0) {
                        const blockLoudness = blockPower / sampleCount;
                        if (blockLoudness > 0) {
                            loudnessValues.push(blockLoudness);
                        }
                    }
                }

                // è®¡ç®—ç§¯åˆ†å“åº¦
                loudnessValues.sort((a, b) => b - a);
                const validCount = Math.floor(loudnessValues.length * 0.9);
                const validValues = loudnessValues.slice(0, validCount);

                if (validValues.length === 0) return -70;

                const meanSquare = validValues.reduce((sum, val) => sum + val, 0) / validValues.length;
                const lufs = -0.691 + 10 * Math.log10(meanSquare + 1e-12);

                return Math.max(lufs, -70);
            }

            // K-weightingæ»¤æ³¢å™¨
            applyKWeighting(channelData, sampleRate) {
                const filtered = [];

                for (let ch = 0; ch < channelData.length; ch++) {
                    const input = channelData[ch];
                    const output = new Float32Array(input.length);

                    // ç®€åŒ–çš„é«˜é€šæ»¤æ³¢å™¨
                    let prev = 0;
                    const alpha = 0.95;

                    for (let i = 0; i < input.length; i++) {
                        output[i] = alpha * (output[i - 1] || 0) + alpha * (input[i] - prev);
                        prev = input[i];
                    }

                    filtered.push(output);
                }

                return filtered;
            }

            // è®¡ç®—å³°å€¼ç”µå¹³
            calculatePeakLevel(audioBuffer) {
                let maxPeak = 0;

                for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
                    const channelData = audioBuffer.getChannelData(ch);
                    for (let i = 0; i < channelData.length; i++) {
                        maxPeak = Math.max(maxPeak, Math.abs(channelData[i]));
                    }
                }

                return maxPeak > 0 ? 20 * Math.log10(maxPeak) : -Infinity;
            }

            // è®¡ç®—åŠ¨æ€èŒƒå›´
            calculateDynamicRange(audioBuffer) {
                const channels = audioBuffer.numberOfChannels;
                const length = audioBuffer.length;
                const sampleRate = audioBuffer.sampleRate;

                const blockSize = Math.floor(sampleRate * 3);
                let loudnessValues = [];

                for (let start = 0; start < length - blockSize; start += blockSize) {
                    let blockPower = 0;
                    let sampleCount = 0;

                    for (let i = start; i < start + blockSize && i < length; i++) {
                        let sample = 0;
                        for (let ch = 0; ch < channels; ch++) {
                            sample += audioBuffer.getChannelData(ch)[i];
                        }
                        sample /= channels;

                        blockPower += sample * sample;
                        sampleCount++;
                    }

                    if (sampleCount > 0) {
                        const blockLoudness = 10 * Math.log10(blockPower / sampleCount + 1e-12);
                        loudnessValues.push(blockLoudness);
                    }
                }

                if (loudnessValues.length < 2) return 0;

                loudnessValues.sort((a, b) => a - b);
                const p95 = loudnessValues[Math.floor(loudnessValues.length * 0.95)];
                const p10 = loudnessValues[Math.floor(loudnessValues.length * 0.10)];

                return Math.max(0, p95 - p10);
            }

            // ç»˜åˆ¶æ³¢å½¢
            drawWaveform(audioBuffer, canvas) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);

                const channelData = audioBuffer.getChannelData(0);
                const step = Math.ceil(channelData.length / width);

                ctx.strokeStyle = '#007bff';
                ctx.lineWidth = 1;
                ctx.beginPath();

                for (let i = 0; i < width; i++) {
                    let min = 1.0;
                    let max = -1.0;

                    for (let j = 0; j < step; j++) {
                        const sample = channelData[i * step + j] || 0;
                        min = Math.min(min, sample);
                        max = Math.max(max, sample);
                    }

                    const y1 = (1 + min) * height / 2;
                    const y2 = (1 + max) * height / 2;

                    if (i === 0) {
                        ctx.moveTo(i, y1);
                    } else {
                        ctx.lineTo(i, y1);
                        ctx.lineTo(i, y2);
                    }
                }

                ctx.stroke();

                // æ·»åŠ ä¸­å¿ƒçº¿
                ctx.strokeStyle = '#dee2e6';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, height / 2);
                ctx.lineTo(width, height / 2);
                ctx.stroke();
            }

            // åˆ›å»ºå¤„ç†åçš„éŸ³é¢‘ç¼“å†²åŒº
            createProcessedAudioBuffer(originalBuffer, gainDB) {
                const gainLinear = Math.pow(10, gainDB / 20);
                const channels = originalBuffer.numberOfChannels;

                const processedBuffer = this.audioContext.createBuffer(
                    channels,
                    originalBuffer.length,
                    originalBuffer.sampleRate
                );

                for (let ch = 0; ch < channels; ch++) {
                    const inputData = originalBuffer.getChannelData(ch);
                    const outputData = processedBuffer.getChannelData(ch);

                    for (let i = 0; i < inputData.length; i++) {
                        let sample = inputData[i] * gainLinear;

                        // è½¯é™åˆ¶é˜²æ­¢å‰Šæ³¢
                        if (Math.abs(sample) > 0.95) {
                            sample = sample > 0 ? 0.95 * Math.tanh(sample / 0.95) : -0.95 * Math.tanh(-sample / 0.95);
                        }

                        outputData[i] = sample;
                    }
                }

                return processedBuffer;
            }

            // æ ¹æ®é€‰æ‹©çš„æ–¹æ¡ˆé‡æ–°åˆæˆè§†é¢‘
            async recombineVideoWithAudio(videoFile, processedAudioBuffer, formatInfo, progressCallback) {
                return new Promise((resolve, reject) => {
                    try {
                        progressCallback(80, 'æ­£åœ¨é‡æ–°åˆæˆè§†é¢‘...');

                        // åˆ›å»ºè§†é¢‘å…ƒç´ 
                        const video = document.createElement('video');
                        video.src = URL.createObjectURL(videoFile);
                        video.crossOrigin = 'anonymous';

                        video.onloadedmetadata = async () => {
                            try {
                                // åˆ›å»ºcanvasç”¨äºè§†é¢‘å¤„ç†
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                canvas.width = video.videoWidth;
                                canvas.height = video.videoHeight;

                                // åˆ›å»ºå¤„ç†åçš„éŸ³é¢‘æº
                                const audioSource = this.audioContext.createBufferSource();
                                audioSource.buffer = processedAudioBuffer;

                                // åˆ›å»ºåª’ä½“æµç›®æ ‡
                                const destination = this.audioContext.createMediaStreamDestination();
                                audioSource.connect(destination);

                                // è·å–canvasæµ
                                const canvasStream = canvas.captureStream(30);

                                // åˆå¹¶è§†é¢‘å’ŒéŸ³é¢‘æµ
                                const combinedStream = new MediaStream([
                                    ...canvasStream.getVideoTracks(),
                                    ...destination.stream.getAudioTracks()
                                ]);

                                // æ ¹æ®é€‰æ‹©çš„æ–¹æ¡ˆè®¾ç½®å½•åˆ¶å‚æ•°
                                let recorderOptions;
                                let outputFormat;

                                if (selectedSolution === 1) {
                                    // æ–¹æ¡ˆä¸€ï¼šé«˜è´¨é‡MP4 (å®é™…è¾“å‡ºWebMï¼Œä½†å°½å¯èƒ½æ¥è¿‘MP4è´¨é‡)
                                    recorderOptions = {
                                        mimeType: 'video/webm;codecs=vp8,opus',
                                        videoBitsPerSecond: 8000000, // 8Mbps - é«˜è´¨é‡
                                        audioBitsPerSecond: 192000   // 192kbps AACè´¨é‡
                                    };
                                    outputFormat = {
                                        container: 'WebM',
                                        videoCodec: 'VP8 (H.264è´¨é‡)',
                                        audioCodec: 'Opus (AACè´¨é‡)',
                                        extension: 'webm'
                                    };
                                } else {
                                    // æ–¹æ¡ˆäºŒï¼šç°ä»£WebM
                                    recorderOptions = {
                                        mimeType: 'video/webm;codecs=vp9,opus',
                                        videoBitsPerSecond: 5000000, // 5Mbps - VP9é«˜æ•ˆå‹ç¼©
                                        audioBitsPerSecond: 192000   // 192kbps
                                    };
                                    outputFormat = {
                                        container: 'WebM',
                                        videoCodec: 'VP9 (æœ€æ–°æ ‡å‡†)',
                                        audioCodec: 'Opus (é«˜è´¨é‡)',
                                        extension: 'webm'
                                    };
                                }

                                // åˆ›å»ºåª’ä½“å½•åˆ¶å™¨
                                const mediaRecorder = new MediaRecorder(combinedStream, recorderOptions);

                                const chunks = [];

                                mediaRecorder.ondataavailable = (event) => {
                                    if (event.data.size > 0) {
                                        chunks.push(event.data);
                                    }
                                };

                                mediaRecorder.onstop = () => {
                                    const processedVideoBlob = new Blob(chunks, { type: 'video/webm' });
                                    progressCallback(100, 'è§†é¢‘å¤„ç†å®Œæˆ!');
                                    resolve({
                                        videoBlob: processedVideoBlob,
                                        outputFormat: outputFormat,
                                        originalFormat: formatInfo
                                    });
                                };

                                // å¼€å§‹å½•åˆ¶
                                mediaRecorder.start();
                                audioSource.start();

                                // ç»˜åˆ¶è§†é¢‘å¸§
                                const drawFrame = () => {
                                    if (!video.ended && !video.paused) {
                                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                                        requestAnimationFrame(drawFrame);
                                    } else {
                                        mediaRecorder.stop();
                                    }
                                };

                                video.play();
                                drawFrame();

                            } catch (error) {
                                reject(error);
                            }
                        };

                        video.onerror = reject;

                    } catch (error) {
                        reject(error);
                    }
                });
            }

            // ä¸»å¤„ç†å‡½æ•°
            async processVideo(videoFile, progressCallback) {
                try {
                    progressCallback(10, 'æ­£åœ¨æå–éŸ³é¢‘æ•°æ®...');
                    const { audioBuffer, formatInfo } = await this.extractAudioData(videoFile, progressCallback);

                    progressCallback(40, 'æ­£åœ¨åˆ†æéŸ³é¢‘å“åº¦...');
                    const originalLUFS = this.calculateLUFS(audioBuffer);

                    progressCallback(50, 'æ­£åœ¨è®¡ç®—éŸ³é¢‘å‚æ•°...');
                    const peakLevel = this.calculatePeakLevel(audioBuffer);
                    const dynamicRange = this.calculateDynamicRange(audioBuffer);

                    progressCallback(60, 'æ­£åœ¨åº”ç”¨å“åº¦è°ƒèŠ‚...');
                    const gainAdjustment = this.targetLUFS - originalLUFS;
                    const processedBuffer = this.createProcessedAudioBuffer(audioBuffer, gainAdjustment);

                    progressCallback(70, 'æ­£åœ¨é‡æ–°åˆæˆè§†é¢‘...');
                    const { videoBlob, outputFormat, originalFormat } = await this.recombineVideoWithAudio(
                        videoFile,
                        processedBuffer,
                        formatInfo,
                        progressCallback
                    );

                    return {
                        originalLUFS: originalLUFS,
                        gainAdjustment: gainAdjustment,
                        peakLevel: peakLevel,
                        dynamicRange: dynamicRange,
                        sampleRate: audioBuffer.sampleRate,
                        originalBuffer: audioBuffer,
                        processedVideo: videoBlob,
                        outputFormat: outputFormat,
                        originalFormat: originalFormat
                    };

                } catch (error) {
                    throw new Error(`è§†é¢‘å¤„ç†å¤±è´¥: ${error.message}`);
                }
            }
        }

        // ä¸»åº”ç”¨ç±»
        class FormatPreserveVideoNormalizer {
            constructor() {
                this.videoProcessor = new FormatPreserveVideoProcessor();
                this.currentFile = null;
                this.processedVideoBlob = null;
                this.outputFormat = null;
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');

                // æ–‡ä»¶æ‹–æ‹½å¤„ç†
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });

                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });

                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.handleFileSelect(files[0]);
                    }
                });

                // æ–‡ä»¶é€‰æ‹©å¤„ç†
                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.handleFileSelect(e.target.files[0]);
                    }
                });
            }

            async handleFileSelect(file) {
                // éªŒè¯æ–‡ä»¶ç±»å‹
                if (!file.type.startsWith('video/')) {
                    alert('è¯·é€‰æ‹©è§†é¢‘æ–‡ä»¶');
                    return;
                }

                // æ£€æŸ¥æ–‡ä»¶å¤§å°
                if (file.size > 2000 * 1024 * 1024) {
                    alert('æ–‡ä»¶å¤ªå¤§ï¼Œè¯·é€‰æ‹©å°äº2GBçš„è§†é¢‘æ–‡ä»¶');
                    return;
                }

                this.currentFile = file;
                this.showProcessingPanel();

                try {
                    await this.processVideo();
                } catch (error) {
                    console.error('å¤„ç†é”™è¯¯:', error);
                    alert(`å¤„ç†å¤±è´¥: ${error.message}\n\nè¯·å°è¯•ä½¿ç”¨è¾ƒå°çš„è§†é¢‘æ–‡ä»¶æˆ–æ£€æŸ¥æ–‡ä»¶æ ¼å¼ã€‚`);
                    this.resetInterface();
                }
            }

            showProcessingPanel() {
                document.getElementById('processingPanel').classList.remove('hidden');
                document.getElementById('resultPanel').classList.add('hidden');
            }

            updateProgress(percentage, status) {
                const progressBar = document.getElementById('progressBar');
                const statusText = document.getElementById('statusText');

                progressBar.style.width = `${percentage}%`;
                statusText.textContent = status;
            }

            async processVideo() {
                const result = await this.videoProcessor.processVideo(
                    this.currentFile,
                    (progress, status) => this.updateProgress(progress, status)
                );

                // æ˜¾ç¤ºéŸ³é¢‘ä¿¡æ¯
                this.displayAudioInfo(result);

                // æ˜¾ç¤ºç»“æœ
                this.showResult(result);
            }

            displayAudioInfo(result) {
                const audioInfo = document.getElementById('audioInfo');
                const originalLUFSElement = document.getElementById('originalLUFS');
                const gainAdjustmentElement = document.getElementById('gainAdjustment');
                const peakLevelElement = document.getElementById('peakLevel');
                const dynamicRangeElement = document.getElementById('dynamicRange');
                const outputSolutionElement = document.getElementById('outputSolution');
                const formatInfoElement = document.getElementById('formatInfo');

                originalLUFSElement.textContent = result.originalLUFS.toFixed(1);
                gainAdjustmentElement.textContent = result.gainAdjustment > 0 ?
                    `+${result.gainAdjustment.toFixed(1)}` : result.gainAdjustment.toFixed(1);
                peakLevelElement.textContent = result.peakLevel.toFixed(1);
                dynamicRangeElement.textContent = result.dynamicRange.toFixed(1);
                outputSolutionElement.textContent = `æ–¹æ¡ˆ${selectedSolution}`;

                // æ ¼å¼ä¿¡æ¯
                const originalInfo = `åŸå§‹: ${result.originalFormat.videoCodec} | ${(result.originalFormat.size / 1024 / 1024).toFixed(1)}MB`;
                const outputInfo = `è¾“å‡º: ${result.outputFormat.container} + ${result.outputFormat.videoCodec} + ${result.outputFormat.audioCodec}`;
                formatInfoElement.textContent = `${originalInfo} â†’ ${outputInfo}`;

                // ç»˜åˆ¶æ³¢å½¢
                const canvas = document.getElementById('waveformCanvas');
                this.videoProcessor.drawWaveform(result.originalBuffer, canvas);

                audioInfo.classList.remove('hidden');
            }

            showResult(result) {
                const resultPanel = document.getElementById('resultPanel');
                const originalVideo = document.getElementById('originalVideo');
                const processedVideo = document.getElementById('processedVideo');
                const downloadBtn = document.getElementById('downloadBtn');
                const originalFormat = document.getElementById('originalFormat');
                const processedFormat = document.getElementById('processedFormat');

                // è®¾ç½®è§†é¢‘æ’­æ”¾å™¨
                originalVideo.src = URL.createObjectURL(this.currentFile);
                processedVideo.src = URL.createObjectURL(result.processedVideo);

                // è®¾ç½®æ ¼å¼ä¿¡æ¯
                originalFormat.textContent = `${result.originalFormat.videoCodec} | ${(result.originalFormat.size / 1024 / 1024).toFixed(1)}MB`;
                processedFormat.textContent = `${result.outputFormat.videoCodec} + ${result.outputFormat.audioCodec}`;

                // å­˜å‚¨å¤„ç†åçš„è§†é¢‘ç”¨äºä¸‹è½½
                this.processedVideoBlob = result.processedVideo;
                this.outputFormat = result.outputFormat;

                // è®¾ç½®ä¸‹è½½åŠŸèƒ½
                downloadBtn.onclick = () => this.downloadProcessedVideo();

                resultPanel.classList.remove('hidden');
            }

            downloadProcessedVideo() {
                if (!this.processedVideoBlob) {
                    alert('æ²¡æœ‰å¯ä¸‹è½½çš„å¤„ç†åè§†é¢‘');
                    return;
                }

                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const link = document.createElement('a');
                const extension = this.outputFormat ? this.outputFormat.extension : 'webm';
                const fileName = this.currentFile.name.replace(/\.[^/.]+$/, `_normalized.${extension}`);

                const url = URL.createObjectURL(this.processedVideoBlob);
                link.href = url;
                link.download = fileName;

                // è§¦å‘ä¸‹è½½
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                // æ¸…ç†URLå¯¹è±¡
                setTimeout(() => URL.revokeObjectURL(url), 1000);
            }

            resetInterface() {
                document.getElementById('processingPanel').classList.add('hidden');
                document.getElementById('resultPanel').classList.add('hidden');
                document.getElementById('audioInfo').classList.add('hidden');
                document.getElementById('progressBar').style.width = '0%';
                document.getElementById('statusText').textContent = 'å‡†å¤‡ä¸­...';

                // æ¸…ç†èµ„æº
                if (this.processedVideoBlob) {
                    URL.revokeObjectURL(this.processedVideoBlob);
                    this.processedVideoBlob = null;
                }

                this.currentFile = null;
                this.outputFormat = null;
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        document.addEventListener('DOMContentLoaded', () => {
            new FormatPreserveVideoNormalizer();
        });

        // é”™è¯¯å¤„ç†
        window.addEventListener('error', (e) => {
            console.error('åº”ç”¨é”™è¯¯:', e.error);
        });

        window.addEventListener('unhandledrejection', (e) => {
            console.error('æœªå¤„ç†çš„Promiseé”™è¯¯:', e.reason);
        });
    </script>
</body>

</html>